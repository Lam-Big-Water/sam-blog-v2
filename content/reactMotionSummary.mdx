---
title: "React Motion Study Summary"
abstract: "React Motion vs CSS Animation. Explain some advantages of React Motion and when to Switch to React Motion."
publishedOn: "2026-01-30"
---

## **When to Use CSS Animations**

### **Advantages**

- **No JavaScript dependency** (better performance)
- **Simple transitions**: hover states, opacity, transform, background-color
- **Simple keyframe animations** that are maintainable in CSS
- **CSS View Transitions** (new powerful feature)

### **Rule of Thumb**

Always **try CSS first** – if it works well, stick with it.

## **When to Switch to Motion**

### **Complex Scenarios**

1. **Multi-step animations** where CSS becomes repetitive/hacky
2. **Math calculations** required (easier in JavaScript)
3. **Multiple variables** beyond CSS custom properties
4. **Advanced interactivity** with application state
5. **Layout animations** (CSS "impossible" animations)
   - e.g., animating flex direction changes

## **Motion Component Basics**

### **What is the Motion Component?**

- **Wrapper** that adds animation capabilities to React components
- **Prefix any JSX element** with `motion.`
- Examples: `motion.div`, `motion.button`, `motion.h1`

### **Usage Examples**

#### **HTML Elements**

```javascript
import { motion } from 'framer-motion'

// Before
<button>Click me</button>

// After - animation-ready
<motion.button>Click me</motion.button>
```

#### **Custom Components**

```javascript
import { motion } from 'framer-motion'
import { MyCustomComponent } from './MyCustomComponent'

// Convert once (outside component for performance)
const AnimatedCustomComponent = motion(MyCustomComponent)

// Usage
<AnimatedCustomComponent>Animation galore!</AnimatedCustomComponent>
```

### **Performance Considerations**

- **Don't convert all elements** – only those needing animation
- **Extra overhead** on motion components
- **Define custom motion components outside** rendering function to avoid recreation

## **Key Concepts**

### **`animate` Prop**

- **Adds animation** to motion components
- Accepts **CSS properties** in camelCase

```javascript
<motion.div animate={{ scale: 2, opacity: 0.5 }} />
```

#### **Two Approaches:**

```javascript
// Single transform property
animate={{ transform: "translateY(30px) scale(0.8) rotate(45deg)" }}

// Individual properties (Recommended)
animate={{ scale: 0.8, rotate: "45deg", y: "30px" }}
```

### **Multiple Animations**

```javascript
animate={{
  scale: 2,
  y: "50%",
  opacity: 0.5,
  rotate: 1800
}}
// All animate simultaneously
```

## **`initial` Prop**

### **Purpose**

- **Override default starting point** of animation
- Accepts **style object** like `animate` prop
- Applied **before animation runs**

### **Example**

```javascript
<motion.button
  className="bg-black" // CSS initial state
  initial={{ background: "#00f" }} // Override: blue → red
  animate={{ background: "#f00" }}
/>
```

## **`transition` Prop**

### **Basic Configuration**

```javascript
transition={{
  duration: 0.5,      // seconds
  ease: "easeInOut",  // easing function
  delay: 2,           // initial delay
  repeat: Infinity,   // or number
  repeatType: "reverse", // "loop", "reverse", "mirror"
  repeatDelay: 0.5,   // delay between repeats
}}
```

## **Spring Animations**

### **Default for Physical Properties**

- **x, y, scale, rotate** use spring by default
- **Natural feel** with overshoot/bounce

### **Spring Configuration**

```javascript
transition={{
  type: "spring",
  bounce: 40,     // overshoot amount
  damping: 10,    // spring resistance
  mass: 3,        // weight of object
  stiffness: 30,  // spring stiffness
  velocity: 100   // initial velocity
}}
```

## **Per-Property Transitions**

### **Granular Control**

```javascript
animate={{
  scaleX: 0.5,
  scaleY: 0.5,
  y: "50%"
}}
transition={{
  duration: 0.5,           // Default for all
  repeat: Infinity,
  scaleX: {                // Override for scaleX
    delay: 1,
    duration: 0.5,
    repeat: Infinity,
    repeatDelay: 1,
  }
}}
```

---

## **Keyframe Basics**

### **Syntax**

- **Array of values** for each property

```javascript
animate={{
  scale: [1, 2, 2, 1, 1],      // 5-step animation
  rotate: [0, 0, 180, 180, 0],
  borderRadius: ["0%", "0%", "50%", "50%", "0%"]
}}
```

### **Timing Behavior**

- **Steps spread evenly** over duration
- **5 steps + 5s duration** = 1s per step
- **Different step counts** cause misalignment between properties

## **Custom Timing with `times`**

### **Purpose**

- **Control percentage timing** of each step
- **Array of numbers 0-1** representing animation progress

### **Example**

```javascript
transition={{
  duration: 2,
  times: [0, 0.5, 0.75, 0.875, 1]
  // Step 1: 0-50% (1s)
  // Step 2: 50-75% (0.5s)
  // Step 3: 75-87.5% (0.25s)
  // Step 4: 87.5-100% (0.25s)
}}
```

### **Default**

`[0, 0.25, 0.5, 0.75, 1]` for 5 steps (even distribution)

## **Inferring Initial Values**

### **`null` as First Value**

- **Automatically infers** from current element state
- **Avoids duplicating** CSS styles

```javascript
animate={{
  borderRadius: [null, "0%", "50%", "50%", "0%"]
  // Initial value from CSS class
}}
```

## **Combining with Transition Settings**

```javascript
transition={{
  duration: 2,
  ease: "easeInOut",
  repeat: Infinity,
  repeatDelay: 1
}}
```

---

## **Interactive Props**

### **`whileHover`**

- **Mouse hover** trigger
- **Excludes touch devices** automatically

```javascript
<motion.button whileHover={{ scale: 1.2 }} />
```

### **`whileFocus`**

- **Keyboard focus** trigger (like `focus-visible`)
- **Excludes mouse/tap** focus
- **Requires focusable element** (add `tabIndex` for non-focusable)

```javascript
<motion.button whileFocus={{ scale: 1.2 }} />
```

### **`whileTap`**

- **Mouse click/touch** trigger
- **Additional callbacks**: `onTap`, `onTapStart`, `onTapCancel`

```javascript
<motion.button whileHover={{ scale: 1.3 }} whileTap={{ scale: 0.8 }} />
```

## **Key Behaviors**

### **Focusability Rules**

- **Buttons/inputs** work out-of-the-box
- **Divs need `tabIndex`** to be focusable
- **Generally advised against** making non-interactive elements focusable

---

---

## **Exercise: Responsive Text Animation**

### **Acceptance Criteria**

1. **Stretch vertically & horizontally** (not simultaneously)
2. **Text fades in** at animation start
3. **Text fades out** at animation end
4. **Animation repeats** with delay between cycles
5. **Creative freedom** beyond basic requirements

### **Implementation Solution**

```javascript
<motion.div
  className="text-[80px] font-family:monospace origin-top-left"
  animate={{
    opacity: [0, 1, 1, 1, 1, 1, 0], // Fade in/out
    scaleX: [1.5, 1.5, 2.5, 2.5, 2.5, 1.5, 1.5], // Horizontal stretch
    scaleY: [0.75, 0.75, 0.75, 1.5, 1.5, 1.5, 8], // Vertical stretch
  }}
  transition={{
    repeat: Infinity,
    repeatDelay: 1,
    times: [0, 0.05, 0.2, 0.3, 0.45, 0.7, 1], // Custom timing
    duration: 18,
  }}
>
  responsive
</motion.div>
```

<ResponsiveTextAnimation />

---

---

## **What are Motion Values?**

### **Core Concept**

- **Internal Framer Motion system** for tracking values
- **Store current value + velocity**
- **No React re-renders** when changed (performance benefit)

### **Creation**

```javascript
import { useMotionValue } from "framer-motion";

const scale = useMotionValue(0); // Initialize with value
```

## **Key Properties & Methods**

### **`.get()` / `.set()`**

```javascript
scale.get(); // Returns current value (number)
scale.set(2); // Updates value immediately
```

### **Framer Motion Enhanced `style` Prop**

- **Accepts motion values directly** (not regular React style)
- **Automatically calls `.get()`** internally

```javascript
<motion.div style={{ scale }} /> // Not style={{ scale: scale.get() }}
```

## **Example: Interactive Scale Control**

### **Setup**

```javascript
const App = () => {
  const scale = useMotionValue(1);

  const onRangeChange = (ev) => {
    scale.set(parseFloat(ev.target.value)); // Direct update
  };

  return (
    <>
      <motion.button style={{ scale }}>Scale ⚖️</motion.button>

      <input type="range" min={0.5} max={5} onChange={onRangeChange} />
    </>
  );
};
```

## **Important Notes**

### **No Automatic Animation**

- **`.set()` updates immediately** – no transition
- **`transition` prop ignored** when using motion values directly
- **You control animation**

### **Performance vs State Management**

- **Don't replace React context/state** with motion values
- **Use for animations only**
- **Similar performance benefits** in state libraries like Zustand

---

---

## **`useSpring` Hook**

### **Purpose**

- **Adds spring physics** to motion value changes
- **Creates bouncy, natural** animations
- **Alternative to `useMotionValue`** for animated transitions

### **Basic Usage**

```javascript
import { useSpring } from "framer-motion";

// Before (no animation)
const scale = useMotionValue(1);

// After (with spring animation)
const scale = useSpring(1); // Automatically bouncy
```

## **Example: Interactive Spring Scale**

### **Implementation**

```javascript
const App = () => {
  const scale = useSpring(1); // Initialize with spring

  const onRangeChange = (ev) => {
    scale.set(parseFloat(ev.target.value)); // Spring animation on change
  };

  return (
    <>
      <motion.button style={{ scale }}>Scale ⚖️</motion.button>
      <input type="range" onChange={onRangeChange} />
    </>
  );
};
```

## **Spring Configuration**

### **Custom Settings**

```javascript
const scale = useSpring(1, {
  stiffness: 200, // Spring tension
  damping: 20, // Resistance/overshoot
  mass: 0.5, // Weight
  velocity: 0, // Initial velocity
});
```

## **Advanced: Chaining Motion Values**

### **Spring Based on Another Motion Value**

```javascript
const baseValue = useMotionValue(0);
const springValue = useSpring(baseValue); // Spring follows baseValue

// Updates to baseValue will animate through spring
```

## **Key Points**

1. **`useSpring` returns motion value** with spring physics
2. **`.set()` triggers spring animation** (not immediate update)
3. **Default spring** provides natural bounciness
4. **Configure spring parameters** for custom feel
5. **Chain motion values** for complex relationships

---

---

## **`useTransform` Hook**

### **Purpose**

- **Map one motion value** to another range
- **Create relationships** between values
- **Enable complex calculations** difficult in CSS

### **Basic Syntax**

```javascript
import { useTransform, useMotionValue } from "framer-motion";

const scrollY = useMotionValue(20); // Source motion value
const opacity = useTransform(
  scrollY, // Source value
  [0, 200], // Input range (source values)
  [0, 1], // Output range (mapped values)
);
```

## **How It Works**

### **Mapping Example**

```javascript
// Input: scrollY value between 0-200px
// Output: opacity between 0-1
useTransform(scrollY, [0, 200], [0, 1]);

// Results:
// scrollY = 0   → opacity = 0
// scrollY = 100 → opacity = 0.5
// scrollY = 200 → opacity = 1
```

### **Key Rules**

1. **Range arrays must be same length**
2. **Linear interpolation** between points
3. **Returns motion value** (not raw number)

## **Interactive Example**

### **Configuration**

```
Input Range: [0, 100]
Output Range: [0, 1]

Input Value: 10 → Output: 0.10
```

### **Formula**

`output = ((input - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin) + outputMin`

## **Practical Applications**

- **Scroll-based animations** (e.g., fade on scroll)
- **Cursor tracking** (map position to visual effects)
- **Complex value relationships** (multiple dependencies)

---

---

## **Making Elements Draggable**

### **Basic Drag Setup**

```javascript
import { motion, useMotionValue } from "framer-motion";

const App = () => {
  const x = useMotionValue(0); // Track position

  return (
    <motion.div
      style={{ x }} // Connect motion value
      drag="x" // Enable horizontal drag
      dragConstraints={{ left: 0, right: 0 }} // Snap back to center
    />
  );
};
```

### **How It Works**

- **`drag="x"`** enables horizontal dragging
- **Custom `x` motion value** captures drag position
- **Framer Motion updates** supplied motion value automatically
- **`dragConstraints`** provides bounce-back behavior

## **Exercise: Transform Drag into Visual Effects**

### **Acceptance Criteria**

1. **Color changes** based on position (left/center/right)
2. **Scale increases** when moving right only
3. **Shape morphs** square→circle when moving left/right
4. **Use hex colors** for animatability

### **Solution Implementation**

```javascript
const App = () => {
  const x = useMotionValue(0);

  // Transform drag position to visual properties
  const borderRadius = useTransform(
    x,
    [-100, 0, 100], // Input: drag position
    ["50%", "0%", "50%"], // Output: square→circle
  );

  const backgroundColor = useTransform(
    x,
    [-100, 0, 100],
    ["#6d4b7e", "#306a87", "#695a37"], // Different colors
  );

  const scale = useTransform(
    x,
    [-100, 0, 100],
    [1, 1, 1.5], // Only scale when moving right
  );

  return (
    <motion.div
      style={{ x, borderRadius, backgroundColor, scale }}
      drag="x"
      dragConstraints={{ left: 0, right: 0 }}
    />
  );
};
```

## **Key Concepts**

### **Motion Value Relationships**

- **Drag position (`x`)** drives multiple visual properties
- **`useTransform` creates synchronized** animations
- **Input/output arrays must match length**

### **Visual Mapping**

```
Position   | Border Radius | Color       | Scale
-----------|---------------|-------------|------
x = -100   | 50% (circle)  | #6d4b7e     | 1
x = 0      | 0% (square)   | #306a87     | 1
x = 100    | 50% (circle)  | #695a37     | 1.5
```

<TransformDrag />

---

---

## **CSS Custom Properties (Variables) Basics**

### **Syntax & Behavior**

```css
:root {
  --header-size: 60px; /* Define variable */
}

.header {
  height: var(--header-size); /* Use variable */
}
```

- **Prefix**: `--` (e.g., `--scale`, `--x`)
- **Inheritance**: Children access parent variables
- **Scoping**: Override-able at any element level

## **Integrating with Framer Motion**

### **Method 1: `style` Prop with Motion Value**

```javascript
import { motion, useMotionValue } from "framer-motion";

const App = () => {
  const scale = useMotionValue(20);

  return (
    <motion.div style={{ "--scale": scale }} />
    // Updates CSS variable when motion value changes
  );
};
```

### **Method 2: Animation Props**

```javascript
<motion.ol
  initial={{ "--x": "0px" }}
  animate={{ "--x": "100px" }}
  transition={{ duration: 1, repeat: Infinity }}
>
  <li className="translate-x-[--x]">CSS</li>
</motion.ol>
```

## **Example: Synchronized Animations**

### **Parent Controls Children**

```javascript
<motion.ol animate={{ "--x": "100px" }} className="flex flex-col gap-3">
  {/* All children use same --x variable */}
  <li className="translate-x-[--x]">CSS</li>
  <li className="translate-x-[--x]">is</li>
  <li className="translate-x-[--x]">the BEST</li>
</motion.ol>
```

### **Tailwind Integration**

```javascript
// Custom translate with CSS variable
className = "translate-x-[--x]"; // Tailwind supports CSS vars
```

## **TypeScript Configuration**

### **Enable Custom Properties**

```typescript
// react.d.ts
declare module "react" {
  interface CSSProperties {
    [key: `--${string}`]: string | number;
  }
}
```

## **Use Cases**

1. **Nested components** sharing animation state
2. **Media query responsive** behavior
3. **Pseudo-element styling** (`:before`, `:after`)
4. **Complex parent-child** animation coordination

---

---

## **Problem: Animating Removed Elements**

- **DOM removal happens immediately** – no time for animation
- **CSS workaround**: `pointer-events: none` + delayed removal (complex)

## **Framer Motion Solution**

### **Components Needed**

#### **1. `AnimatePresence` Wrapper**

```javascript
import { AnimatePresence } from "framer-motion";

<AnimatePresence>{/* Elements to animate on exit */}</AnimatePresence>;
```

- **Keeps elements in DOM** until exit animation completes
- **Manages lifecycle** of conditional elements

#### **2. `exit` Prop**

```javascript
<motion.div
  initial={{ opacity: 0, scale: 0.9 }}
  animate={{ opacity: 1, scale: 1 }}
  exit={{ opacity: 0, scale: 0.9 }} // Animation on removal
/>
```

## **Implementation Example**

### **Toggle Visibility Demo**

```javascript
const App = () => {
  const [isVisible, setIsVisible] = useState(true);

  return (
    <>
      <button onClick={() => setIsVisible((prev) => !prev)}>Toggle</button>

      <AnimatePresence initial={false}>
        {isVisible && (
          <motion.div
            initial={{ opacity: 0, scale: 0.9, y: 20 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            exit={{ opacity: 0, scale: 0.9, y: 20 }}
          >
            Random card
          </motion.div>
        )}
      </AnimatePresence>
    </>
  );
};
```

## **Key Points**

### **Multiple Elements**

- **Require unique `key` prop** for tracking
- Helps Framer Motion identify elements

### **Preventing Initial Animation**

```javascript
<AnimatePresence initial={false}>
  {/* No animation on initial render */}
</AnimatePresence>
```

## **How It Works**

1. **Element conditionally rendered** (e.g., `isVisible && <Component />`)
2. **Condition becomes false** → element scheduled for removal
3. **`AnimatePresence` intercepts** removal
4. **`exit` animation runs**
5. **After completion**, element actually removed from DOM

## **Benefits**

- **Clean API** vs CSS workarounds
- **Synchronized** enter/exit animations
- **Automatic lifecycle management**

<AnimatingRemoved />

---

---

## **What are Variants?**

### **Definition**

- **JavaScript objects** containing animation styles
- **Named states** (e.g., `visible`, `hidden`, `open`, `closed`)
- **Reduce code repetition** across animation props

### **Basic Example**

```javascript
const variants = {
  visible: { opacity: 1, x: 0 },
  hidden: { opacity: 0, x: 30 }
}

<motion.div
  variants={variants}
  initial="hidden"
  animate="visible"
  exit="hidden"
/>
```

## **Key Features**

### **1. Multiple Usage Points**

- Works with **all animation props**: `whileHover`, `whileTap`, `whileFocus`
- **Single definition**, multiple uses

### **2. Variant Inheritance**

- **Parent's `animate` variant** automatically applies to children
- **Children can override** with own `animate` prop
- **Control multiple animations** from single parent state

## **Example: Modal with Inherited Variants**

### **Parent Component**

```javascript
<motion.div
  variants={{
    open: { opacity: 1, y: 0 },
    closed: { opacity: 0, y: 20 }
  }}
  initial="closed"
  animate="open" // Controls ALL child variants
  exit="closed"
>
```

### **Child Component (inherits `open`/`closed`)**

```javascript
<motion.button
  variants={{
    open: { scale: 1 },
    closed: { scale: 0 }, // Inherits parent's active variant
  }}
  // No need for animate prop - inherits from parent
/>
```

## **Multiple Variants Support**

### **Array Syntax**

```javascript
<motion.div
  variants={variants}
  initial={["hidden", "inactive"]}
  animate={["visible", "active"]}
/>
```

- **Apply multiple variants** simultaneously
- **Rarely needed** in practice

## **Benefits**

1. **DRY code**: Eliminate style repetition
2. **Centralized control**: Parent manages child animations
3. **Clean organization**: Logical grouping of animation states
4. **Flexible**: Works with all interactive states

## **Use Cases**

- **Modals/dialogs** with coordinated enter/exit animations
- **Interactive components** with multiple states
- **Complex UI** with synchronized animations

```javascript
<AnimatePresence initial={false}>
  {toggle && (
    <motion.div
      variants={{
        open: {
          opacity: 1,
          y: 0,
        },
        closed: {
          opacity: 0,
          y: 20,
        },
      }}
      initial="closed"
      animate="open"
      exit="closed"
      className="flex h-26 w-32 items-center justify-center rounded-sm bg-white"
    >
      <div className="h-18 w-26 bg-gray-400"></div>
    </motion.div>
  )}
</AnimatePresence>
```

<Variants />

---
---

## **Staggered Animations Concept**

### **Parent-Child Coordination**

- **Parent variants inherited** by children
- **`staggerChildren`**: Delay between child animations
- **`when: "afterChildren"`**: Parent waits for children

### **Parent Variant Definition**

```javascript
const containerVariants = {
  hidden: {
    opacity: 0,
    transition: {
      staggerChildren: 0.1, // 0.1s delay between children
      staggerDirection: -1, // Reverse order (last→first)
      when: "afterChildren", // Parent waits
    },
  },
  visible: {
    opacity: 1,
    transition: {
      staggerChildren: 0.1, // Normal order (first→last)
    },
  },
};
```

## **Exercise: Animated Navigation Menu**

### **Acceptance Criteria**

1. **Menu grows** when opened
2. **Menu items animate in** with staggered delay
3. **Menu items animate out** with reverse stagger
4. **Menu closes only after** children finish animating

### **Solution Implementation**

#### **Parent Container**

```javascript
<motion.div
  initial="hidden"
  animate={navigationIsVisible ? "visible" : "hidden"}
  variants={{
    hidden: {
      width: 74,
      transition: {
        staggerChildren: 0.1,
        staggerDirection: -1, // Reverse on close
        delay: (menuItems.length - 2) * 0.1 // Wait for children
      }
    },
    visible: {
      width: 200,
      transition: { staggerChildren: 0.1 } // Normal order
    }
  }}
>
```

#### **Child Menu Items**

```javascript
<motion.li
  variants={{
    hidden: { opacity: 0, x: -100 },
    visible: { opacity: 1, x: 0 },
  }}
  // Inherits parent's variant + stagger timing
>
  {item}
</motion.li>
```

## **Key Features**

### **Stagger Direction**

- **`1` (default)**: First → last child
- **`-1`**: Last → first child (reverse)

### **Timing Control Options**

```javascript
// Option 1: Automatic waiting
when: "afterChildren";

// Option 2: Manual delay calculation
delay: (menuItems.length - 2) * 0.1;
```

<StaggeredAnimations/ >

---
---

## **Responsive Overview**

### **Goal**

Create a **notification component** with **different animations** for mobile vs desktop

### **Demo Preview**

- **Desktop animation**: Side panel slide-in
- **Mobile animation**: Bottom sheet/popup
- **Toggle functionality** with bell icon

## **Responsive Approach Philosophy**

### **CSS-First Mindset**

- **Web is inherently responsive**
- **Smart CSS techniques** can avoid media queries
- **Leverage default responsive behavior**

## **Key Takeaway**

- **Multiple Framer Motion approaches** available
- **Some approaches better** than others
- **CSS foundations** reduce complexity

## **Next Steps**

- **CSS techniques** lesson (before Framer Motion specifics)
- **Building responsive notification component**

---

This content covers **responsive CSS techniques without media queries**, not React Query.

## **Philosophy: Web is Inherently Responsive**

- **Text flows naturally** without intervention
- **We add complexity** through unnecessary constraints
- **Mobile-first approach** introduced fixed breakpoints

## **Techniques to Avoid Media Queries**

### **1. Min/Max Width/Height**

```css
/* With media query */
.container {
  width: 50%;
}
@media (min-width: 768px) {
  .container {
    width: 768px;
  }
}

/* Without media query */
.container {
  max-width: 768px;
  width: 50%;
}
```

### **2. CSS Grid**

```css
/* Responsive grid - no media queries */
.container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
  /* Auto-adjusts columns, minimum 100px */
}
```

### **3. Flexbox**

```css
/* Basic wrapping */
.container {
  display: flex;
  flex-wrap: wrap;
}

/* Growing items */
.child {
  width: 100px;
  flex-grow: 1; /* Fill available space */
}
```

### **4. Specialized CSS Units**

- **`ch`**: Character width (e.g., `max-width: 50ch`)
- **`cq*`**: Container query units (relative to parent)
- **`vw`/`vh`**: Viewport units

### **5. CSS Math Functions**

```css
/* Calculations */
.wrapper {
  width: calc(50% - 20px);
}

/* Clamping values */
.image {
  width: clamp(50%, 480px, 100%);
}

/* Min/Max selection */
.video {
  width: min(50%, 480px);
} /* Takes smaller */
.video {
  width: max(50%, 480px);
} /* Takes larger */
```

## **Key Principles**

### **Fluid vs Fixed Thinking**

- **Web is fluid** by nature
- **Avoid fixed breakpoints** when possible
- **Combine properties** creatively

### **Maintainability Balance**

- **Don't overcomplicate** to avoid media queries
- **Choose simplest solution** for each case
- **Media queries still valid** for certain scenarios

---
---

## **Recommended Approach in Responsive: CSS Variables**

### **Why CSS Variables?**

- **Breakpoints defined in CSS** only (no JavaScript duplication)
- **No need to detect screen size** in JavaScript
- **Works with looping animations** (other approaches fail)

### **Implementation**

#### **1. Animate CSS Variables**

```javascript
<motion.div
  variants={{
    opened: {
      "--x": "0%", // Desktop: horizontal
      "--y": "0%", // Mobile: vertical
      opacity: 1,
    },
    closed: {
      "--x": "-100%",
      "--y": "100%",
      opacity: 0,
    },
  }}
  initial="closed"
  animate={isOpened ? "opened" : "closed"}
/>
```

#### **2. Apply Variables in CSS/Tailwind**

```javascript
className = "max-sm:translate-y-[--y] md:translate-x-[--x]";
```

- **Mobile**: `translate-y-[--y]`
- **Desktop**: `translate-x-[--x]`

### **Important: String Values**

```javascript
// ✅ Correct
"--x": "100px"

// ❌ Wrong (won't work for CSS variables)
"--x": 100
```

## **Exercise: Responsive Drawer**

### **Acceptance Criteria**

1. **Desktop**: Animate from left (`--x: "-100%" → "0%"`)
2. **Mobile**: Animate from bottom (`--y: "100%" → "0%"`)

### **Solution**

```javascript
<motion.div
  variants={{
    opened: {
      opacity: 1,
      "--x": "0%",
      "--y": "0%",
    },
    closed: {
      opacity: 0,
      "--x": "-100%",
      "--y": "100%",
    },
  }}
  initial="closed"
  animate={isOpened ? "opened" : "closed"}
  className="max-sm:translate-y-[--y] md:translate-x-[--x]"
/>
```

## **Alternative Scenarios**

### **Different Values Per Breakpoint**

```javascript
// Two separate variables
"--y-desktop": "50%",
"--y-mobile": "100%"
```

## **CSS-Only Challenge**

- **Possible with CSS animations + media queries**
- **More complex** than Framer Motion solution
- **Good learning exercise**

## **Key Benefits**

1. **Single source of truth** for breakpoints
2. **Clean separation** of concerns
3. **Works with all** animation types (including loops)
4. **Minimal JavaScript** logic

## **Exercise: Responsive Notifications Component**

### **Goal**

Combine **exit animations**, **staggered animations**, and **responsive behavior**:

- **Desktop**: Notifications slide in from right
- **Mobile**: Notifications slide up from bottom
- **Staggered entry/exit** of notification items

### **Solution Implementation**

#### **Parent Container with Stagger**

```javascript
<AnimatePresence initial={false}>
  {showNotifications && (
    <motion.div
      variants={{
        open: {
          opacity: 1,
          transition: { staggerChildren: 0.1 } // Entry stagger
        },
        closed: {
          opacity: 0,
          transition: {
            staggerChildren: 0.04,
            staggerDirection: -1 // Exit reverse stagger
          }
        }
      }}
      initial="closed"
      animate="open"
      exit="closed"
    >
```

#### **Child Notification Items with CSS Variables**

```javascript
<motion.li
  variants={{
    open: {
      opacity: 1,
      "--x": "0px",   // Desktop: horizontal
      "--y": "0px"    // Mobile: vertical
    },
    closed: {
      opacity: 0,
      "--x": "30px",
      "--y": "30px"
    }
  }}
  className="max-sm:translate-y-[--y] md:translate-x-[--x]" // Responsive application
>
```

### **Key Techniques Used**

1. **`AnimatePresence`** for exit animations
2. **Parent-controlled stagger** with `staggerChildren`
3. **Reverse stagger** on exit (`staggerDirection: -1`)
4. **CSS variables** for responsive positioning
5. **Tailwind responsive classes** (`max-sm:`, `md:`)

## **Responsive Behavior**

- **Mobile (`max-sm`)**: `translate-y-[--y]` (vertical movement)
- **Desktop (`md`)**: `translate-x-[--x]` (horizontal movement)

## **Animation Flow**

1. **Container fades in/out** with opacity
2. **Children stagger in/out** with position + opacity
3. **Exit animations reverse** stagger order
4. **Responsive positioning** per breakpoint

## **Complete Module Skills**

- ✅ Exit animations with `AnimatePresence`
- ✅ Variant inheritance
- ✅ Staggered child animations
- ✅ Responsive animations with CSS variables
- ✅ CSS-first responsive techniques

<ResponsiveDrawer />

---
---

## **Module Summary: Trigger Animations on Scroll**

**Key Concepts:**

- **Scroll-Triggered Animations:** Animations that activate once when an element enters the viewport (e.g., reveal effects, sound effects).
- **Scroll-Driven Animations:** Animations that continuously update while scrolling (e.g., progress indicators, dynamic bento grid effects).
- **Position Sticky + Scroll:** Using `position: sticky` with scroll animations for advanced visual effects.

**Implementation Focus:**

1. Creating engaging but non-distracting animations.
2. Avoiding overuse to maintain good UX.
3. Practical examples: reveal animations, sound triggers, progress indicators, bento grid animations, and sticky-based scroll effects.

**Goal:** Enhance page engagement with controlled, purposeful scroll animations.

---

**Summary: `whileInView` – Scroll-Triggered Animations**

**Core Concept:**  
Animations that trigger when an element enters/exits the viewport (scroll-triggered), not continuously updating during scroll.

**Key Prop:** `whileInView`

- Works like `animate` or `whileHover` – accepts animation objects or variant names.
- Example: Fades in and changes border-radius when element enters view.

**Important Props:**

1. **`initial`**: Defines starting state. If omitted, browser defaults apply (e.g., `opacity: 1`), which may skip animations.
2. **`animate`**: Defines end state after element leaves view (often matches `initial`).
3. **`viewport`**: Configures trigger timing:
   - `amount`: Fraction of element in view needed to trigger (e.g., `0.5` = 50%).
   - `margin`: Adjusts trigger boundaries.
   - `once`: Triggers animation only once.
   - `root`: Sets custom scroll container.

**Animating Multiple Children:**  
Use **variants** with `staggerChildren` on a parent to sequence child animations. Example:

- Parent variant controls `staggerChildren`.
- Child variants define `inView`/`outOfView` states.

**Exercise Solution:**  
Convert direct props to variants:

- Parent: `whileInView="inView"`, `initial="outOfView"`, `animate="outOfView"`.
- Children: Define `inView` (visible) and `outOfView` (hidden) variants.
- Parent variant uses `staggerChildren` for delayed sequencing.

**UX Tip:**  
Use `viewport` to fine-tune trigger points, preventing missed animations.

<WhileInView />

---
---

**Summary: `useInView` Hook**

**Purpose:**  
A React hook that tracks when an element enters/exits the viewport, returning a boolean (`isInView`). Useful for triggering JavaScript logic (e.g., playing sounds, logging, conditional rendering).

**Basic Usage:**

```javascript
const elementRef = useRef(null);
const isInView = useInView(elementRef, options);
```

- Pass a `ref` to the element you want to track.
- Returns `true` when element is in view, `false` otherwise.

**Options:**  
Same as `viewport` prop in `whileInView`:

- `amount`: Fraction of element needed in view (e.g., `0.9` = 90%).
- `margin`: Adjusts trigger boundaries.
- `once`: Trigger only once.
- `root`: Custom scroll container.

**Responding to State:**

- Use `useEffect` to run side effects (e.g., play sound) when `isInView` changes.
- Use `animate` prop with variants to trigger animations based on `isInView`.

**Example (Sound + Animation):**

1. Play sound when element enters view:
   ```javascript
   useEffect(() => {
     if (isInView) playSound();
   }, [isInView]);
   ```
2. Animate element using `animate` prop with variants:
   ```javascript
   <motion.img
     variants={{ hidden: { opacity: 0 }, visible: { opacity: 1 } }}
     animate={isInView ? "visible" : "hidden"}
     ref={elementRef}
   />
   ```

**Key Takeaway:**  
`useInView` provides programmatic control over scroll-triggered events, complementing `whileInView` for more complex interactions.

<UseInView />

---
---

**Summary: `useScroll` Hook for Scroll-Driven Animations**

**Purpose:**  
Tracks scroll position and progress for creating animations linked to scroll movement.

**Basic Usage:**

```javascript
const { scrollYProgress, scrollY, scrollXProgress, scrollX } = useScroll();
```

- `scrollY`/`scrollX`: Pixels scrolled (motion values).
- `scrollYProgress`/`scrollXProgress`: Progress from 0 to 1 (motion values).

**Example – Scroll Progress Indicator:**

1. Use `scrollYProgress` to drive `scaleX` of a progress bar.
2. Apply `origin-left` (or `transformOrigin: "left"`) to scale unidirectionally.
3. Optional: Wrap with `useSpring` for smooth interpolation (avoid for scroll hijacking).

**Solution:**

```javascript
const { scrollYProgress } = useScroll();
const scaleX = useSpring(scrollYProgress); // Optional smoothing

<motion.div style={{ scaleX }} className="origin-left" />;
```

**Tracking Container Scroll:**  
To track scroll inside an element (not the window):

```javascript
const containerRef = useRef(null);
const { scrollXProgress } = useScroll({ container: containerRef });

<div ref={containerRef} className="overflow-x-auto">
  {/* Content */}
</div>;
```

**Key Points:**

- Directly map scroll progress to animation properties (e.g., `scaleX`).
- Use `container` option for scrollable containers.
- Avoid artificial scroll smoothing to prevent UX issues (scroll hijacking).

<UseScroll />

---
---

**Summary: Tracking Element Position with `useScroll`**

**Purpose:**  
Track an element's scroll progress within the viewport (or a container) using the `useScroll` hook.

**Key Configuration Properties:**

1. **`container`** (default: `window`)  
   The scrollable element to track (pass a `ref` to track a specific container).

2. **`target`** (default: container's scrollable area)  
   The element whose visibility is tracked (pass a `ref` to an element).

3. **`offset`** (default: `["start start", "end end"]`)  
   Defines the start (`0`) and end (`1`) points of scroll progress.  
   Format: `["{targetPosition} {containerPosition}", "{targetPosition} {containerPosition}"]`
   - **Positions**: `"start"`, `"center"`, `"end"`.
   - **Example**: `["start end", "end start"]` means:
     - `0`: Target start meets container end (top of element at bottom of viewport).
     - `1`: Target end meets container start (bottom of element at top of viewport).

**Understanding Default Behavior:**  
With `offset: ["start start", "end end"]`:

- `0`: Top of target meets top of container.
- `1`: Bottom of target meets bottom of container.
- Progress runs **backward** (`1` → `0`) when scrolling top to bottom.

**Reversing Progress:**  
Swap offset values to make progress run `0` → `1`:  
`["end end", "start start"]`

**Alternative Offset Units:**

- **Numbers**: `0` to `1` (e.g., `["0.5 0.5", "0 1"]`).
- **Pixels**: (e.g., `["100px 100px", "-50px 150px"]`).
- **Percentages**: (e.g., `["50% 50%", "0% 100%"]`).
- **Viewport units**: `vw`/`vh` (e.g., `["50vw 50vw", "0vh 100vh"]`).

**Example Usage:**

```javascript
const elementRef = useRef(null);
const { scrollYProgress } = useScroll({
  target: elementRef,
  offset: ["start end", "end start"],
});
```

**Key Insight:**  
`offset` controls when scroll progress begins/ends relative to target and container. Adjust it to match desired animation triggers.

**Summary: Practicing Scroll-Triggered vs. Scroll-Driven Animations**

**Objective:**  
Create similar bento-grid animations using both `useInView` (scroll-triggered) and `useScroll` (scroll-driven) to compare their behaviors.

**Implementation:**

**1. Scroll-Triggered (`useInView`)**

- **Approach**: Wrap grid in `motion.div` with `useInView` hook.
- **Logic**:
  - Track grid visibility (`amount: 0.3` → triggers when 30% is in view).
  - Use `animate` prop with variants (`"inView"`/`"outOfView"`).
  - Parent variant staggers children animations (`staggerChildren: 0.1`).
- **Result**: Instant animation when grid enters/exits viewport.

**2. Scroll-Driven (`useScroll`)**

- **Approach**: Create `FadeIn` wrapper component using `useScroll`.
- **Logic**:
  - Track element’s scroll progress with `target` ref.
  - Define `offset: ["start end", "end start"]` (fades in/out as element passes through viewport).
  - Map scroll progress to opacity via `useTransform`:  
    `[0, 0.15, 0.80, 1]` → `[0, 1, 1, 0]` (fade in early, fade out late).
- **Result**: Smooth opacity change tied to scroll position.

**Key Differences:**

- **Scroll-Triggered**: Binary state (in/out) → instant animation.
- **Scroll-Driven**: Continuous progress → animation updates with scroll.

**Best Practices:**

- Use **variants** to reduce code repetition.
- Wrap elements in `motion.div` instead of modifying base components.
- Use `useTransform` to map scroll progress to animation values.

**Summary: Scroll Animations with `position: sticky`**

**Concept:**  
Combine `position: sticky` with scroll-driven animations to create elements that "stick" during scroll, enabling extended, immersive animations.

**How `position: sticky` Works:**

- Element behaves normally until it reaches a defined offset (e.g., `top: 0`) within its scrollable parent.
- It then "sticks" in place until the parent scrolls past.
- Ideal for creating prolonged visibility during scroll.

**Animation Technique:**

1. **Track Parent Scroll**: Use `useScroll` on the parent container (e.g., a tall `div`) to get `scrollYProgress`.
2. **Map to Animations**: Use `useTransform` to convert `scrollYProgress` into animation values (e.g., `translateX`, `opacity`, `scale`).
3. **Apply to Sticky Element**: Attach transformed values to the sticky element's `style` prop.

**Example Implementation:**

```javascript
const ref = useRef(null);
const { scrollYProgress } = useScroll(); // Track window scroll

// Map scroll progress to animation values
const x = useTransform(scrollYProgress, [0.15, 0.83], [0, -300]);
const opacity = useTransform(scrollYProgress, [0.66, 0.72], [1, 0]);

return (
  <div ref={ref} className="h-[300vh]">
    {" "}
    {/* Tall parent */}
    <motion.div
      className="sticky top-1/2" // Sticks in view
      style={{ x, opacity }} // Animates with scroll
    >
      {/* Content */}
    </motion.div>
  </div>
);
```

**Key Benefits:**

- Allows longer, smoother animations as element remains visible.
- Control animation speed via parent height (taller = slower).
- Creates engaging visual narratives during scroll.

**Use Case:**  
Perfect for highlighted text, image carousels, or interactive storytelling that unfolds during scrolling.

<ScrollProgress />

---
---

**Module Summary: Layout Animations in Framer Motion**

**Core Concept:**  
Layout animations automatically interpolate between element states (position, size, layout) when changes occur—creating smooth, "magical" transitions with minimal code.

**Module Projects & Learning Path:**

1. **Form Submit Animation**
   - Animate a button state change on form submission.
   - Demonstrates ease and performance benefits over CSS.

2. **Record Player Component**
   - Animate layout changes (flex direction, resizing) not possible with CSS alone.
   - Highlights cleaner, more readable code.

3. **Expanding Navigation**
   - Combine layout animations with `AnimatePresence`.
   - Animate dynamic list items while wrapper adjusts size automatically.

4. **Shared Layout Animations**
   - Transition elements smoothly across component states (e.g., active indicators).
   - Enables morphing-like effects between components.

5. **Music Player**
   - Integrates all concepts: a single item morphs into a full-screen detail view.
   - Showcases complex layout transformations.

**Key Takeaway:**  
Layout animations automate complex state transitions, making advanced UI interactions simpler, more performant, and visually impressive.

---

**Summary: First Layout Animation**

**Core Idea:**  
Layout animations automatically animate between different component layouts, handling performance optimizations for you.

**Key Points:**

1. **Problem with CSS-Only Approach**
   - Animating properties like `width`, `height`, or `position` can cause performance issues (triggers layout recalculations).
   - Workarounds (e.g., absolute positioning + width animation) are complex and inefficient.

2. **Framer Motion’s Solution**
   - Add `layout` prop to a `motion` element to enable layout animations.
   - Framer Motion converts non-performant animations (e.g., width changes) into optimized `transform` animations behind the scenes.
   - You define the start/end states; Framer Motion handles the transition smoothly and efficiently.

**Example: Form Submit Button**

- Toggle button between "Send" (compact) and "Sent!" (expanded) states.
- Add `layout` prop to `motion.button` → automatically animates width/color changes.
- Use `motion.span` with `layout` for nested elements to prevent distortion.

**Performance Benefit:**  
Leverages GPU-accelerated `transform` and `opacity` animations instead of triggering layout thrashing.

**Takeaway:**  
Layout animations simplify complex UI transitions while ensuring performance—just add `layout` and let Framer Motion handle the rest.

**Summary: Animating the Impossible with Layout Projections**

**Core Concept:**  
Framer Motion's Layout Animations can animate CSS properties that are normally non-animatable (e.g., `flex-direction`) using **Layout Projections**.

**How Layout Projections Work (FLIP-like):**

1. **Snapshot Start/End States:** Capture bounding boxes (position, size) before and after layout change.
2. **Calculate Transform:** Compute the difference as a CSS `transform` (translate/scale) to simulate the start state.
3. **Apply & Animate:**
   - Instantly apply end-state styles.
   - Apply counter-transform to make element appear at start state.
   - Animate transform back to zero for smooth transition.

**Key Advantages:**

- **Performance:** Uses optimized `transform` animations instead of layout-thrashing properties.
- **Child Preservation:** Applies inverse transforms to children to prevent distortion (e.g., text/buttons don't stretch).
- **Visual Consistency:** Maintains properties like `border-radius` during scaling.

**Example: Record Player Component**

- Toggle `flex-direction` between `row` and `column`.
- Animate size, padding, and font scaling simultaneously.
- Add `layout` prop to parent and children to enable smooth transitions.

**Takeaway:**  
Layout Projections enable complex, performant animations that are impossible with CSS alone—just define state changes and let Framer Motion handle the rest.

<LayoutAnimation />

---
---
**Summary: Shared Layout Animations**

**Concept:**  
Animate between **different components** as if they’re the same element by sharing a `layoutId`. Creates the illusion of a single element moving/sizing between positions.

**Key Requirements:**

1. **Shared `layoutId`**: Assign the same `layoutId` string to motion elements you want to link.
2. **Conditional Rendering**: Only one linked element should be visible at a time (e.g., active state toggles).
3. **Positioning**: Use `position: absolute` (or flex/grid) for smooth transitions without layout shifts.

**Example: Navigation Active Indicator**

```javascript
const [activeIndex, setActiveIndex] = useState(0);

return (
  <ul>
    {items.map((item, index) => (
      <li key={item} onClick={() => setActiveIndex(index)}>
        {/* Conditional indicator with shared layoutId */}
        {activeIndex === index && (
          <motion.span
            layoutId="indicator"
            className="absolute inset-0 rounded-full bg-gray-300"
          />
        )}
        <a className="relative z-10">{item}</a>
      </li>
    ))}
  </ul>
);
```

**How It Works:**

- When `activeIndex` changes, the previous indicator unmounts and the new one mounts.
- Framer Motion recognizes matching `layoutId`s and animates size/position between them.
- Creates seamless transition as if one indicator is moving.

**Visual Tips:**

- Use `absolute` positioning + `inset-0` to fill parent.
- Add `rounded-full` in **style prop** (not class) to avoid radius distortion.
- Text needs `relative z-10` to appear above indicator.

**Use Cases:**  
Active states, tab indicators, image carousels, morphing UI elements.

<LayoutId />

---
---

**Summary: Alternative to Position Absolute with CSS Grid**

**Why Avoid `position: absolute`:**

- Removes element from document flow → parent shrinks, requires manual padding/width adjustments.
- Fixed widths and manual calculations make layouts brittle.

**CSS Grid Solution:**  
Use grid columns to overlap elements naturally, with better control and responsiveness.

**Steps to Overlap with CSS Grid:**

1. **Define Grid Columns:**

   ```css
   .form {
     display: grid;
     grid-template-columns: 1fr 120px; /* Input expands, button fixed */
   }
   ```

2. **Place Elements in Grid:**

   ```css
   .input {
     grid-row: 1;
     grid-column: 1;
   }
   .button {
     grid-row: 1;
     grid-column: 2;
   }
   ```

3. **Overlap on State Change:**  
   Animate `grid-column` via layout animations:
   ```jsx
   <motion.button
     layout
     style={{
       gridColumn: isSubmitted ? "1 / span 2" : "2"
     }}
   >
   ```

**Key Benefits:**

- **Cleaner Layout:** No manual padding/width hacks.
- **Responsive:** Grid adjusts naturally to content.
- **Animatable:** `grid-column` changes become smooth with `layout` prop.

**Example Result:**  
Button expands to span both columns (overlapping input) when submitted, animated seamlessly by Framer Motion.

**Takeaway:**  
CSS Grid + layout animations provide a robust, maintainable alternative to `position: absolute` for overlapping UI elements.

<GridLayout />